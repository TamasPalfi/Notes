# Python3 Technical Interview Notes
Notes for **Python3 interview tips** will be located here.  It will primarily consist of basic topics that are commonly tested on **technical interviews** such as string methods, integer methods, common data structures, common algorithms, and so on.  It might not include very basic information which is already known to me, and it will eventually include more complex things as my preparation goes further.  I will be including anything that I feel the need to have a 2nd look on before any technical interview.  This will likely be my most extensive technical interview notes page as I am currently focused on improving my python skills with the **goal of obtaining a data science or ML job** out of college.  Most of these notes will be the results of practicing technical questions on [LeetCode](https://leetcode.com/).  Check out the website, it is a great resource to prep for an interview in any language.  *These notes are for public use but please cite me (@TamasPalfi) if showcase it elsewhere as I have done with all the wonderful resources/people I have used to create this.*. 

## Good Technical Interview Practices
- strongly consider stating and even writing out the brute force solution to a problem first if a better solution doesn't immediatly come to mind.  Important to solve the problem at hand first and then optimize.  However, this isn't always an option given the quick assessment times of many online tests.  Also, good choice to fall back to if cant find the best solution.
- **Ask: Can I use a Dictionary/HashTable to solve this problem?**
- think about time and space complexity always when solving a problem and how to optimize, AND usually in that order.  Most often you want to reduce time complexity but there are times where space considerations have to be made (not a lot of memory to work with or dealing with a lot of data)

## General 
- *is* should be used for identity testing.  It is the same as id(a) == id(b).  *EX: Checking to see if a an element of a list matches an target object, you would use is.*
- *==* is used for equality comparison/testing.  It would be used to see if two objects contain the same data.  *EX: Checking to see if two strings are equal to one another*
- improve performance speed tips located [here](https://wiki.python.org/moin/PythonSpeed/PerformanceTips) **(TODO: Read thru this!!!)**
- dont forget that python is written in C (well CPython actually) - if can't remember a certain important python 'thing' it would be wise to consider how that same thing works in C.
- if ask to not use a certain operator (+, -, * ..) then usually want you to use bit shiting (&, ^, <<).

## Strings



## Integers


## Loops
- **while** and **for** loops.  **while** should be used  when you want to loop until a certain condition is met.  **for** loop should be used when you have an iterable or know precisely how many times you would like the loop to iterate for. 
- **NOTE:** each operation within a loop will be called for each iteration - thus, the best way to improve the runtime is to **keep your loops simple**.  Best solution would be to try to find solution w/o any looping but that's not always the case.
- Which loop is faster? **A:** Often the difference is neglibable and they both are equally or very similarly fast.  The first question should always be the one mentioned in the first bullet: am I looping until a certain condition or simply over an iterable/known # of times?  However, under the hood it is often the case that the for loop is actually slightly faster.  This is due to how for loops often utilize range() in their looping statement which is executed purely in C, opposed to incrementing a *count* variable in the while loop which is interpreted by python (which will be slower than the C code).  [Source1](https://stackoverflow.com/questions/869229/why-is-looping-over-range-in-python-faster-than-using-a-while-loop) & [Source2](https://www.quora.com/Which-loop-is-more-efficient-in-C)
- Loops in general have a lot of overhead so the best way is to actually try to make your code use C as often as possible.  Instead of using a for loop consider using *map* or a *list comprehension* that is executed in C rather than the python interpreter. **This is the fastest option.**  Please see the section *loops* in this [source](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)
- Other tips from the above source include:
  - Avoid using . in the loop when calling a function.  That is a function reference that will be reevaluated everytime the loop iterates.  Instead you can define the function call before the loop, however this may come at the cost of code readability.
  - Use local variables rather than global variables as python utilizes them much quicker.  A way to do this is to set up the loop in a function thus making previous . function calls into local rather than global.  

## Dictionaries
- **BIG TIP TO NOTE:** Python's dictionaries are implemented as Hash Tables (and as such have same time/space complexities)!  See python documentation [here](https://docs.python.org/3/library/stdtypes.html#typesmapping)  Thus, I would recommend in interviews to use dictionaries as you are quite often more familiar with them due to it being one of the key data structures taught, but mention to the interviewer this distinction. 
- Dictionaries are faster than looking up data objects than a list (most of the time - if object needed is first element in list then 
- Key Difference between Dictionaries and HashTables:* Although dictionaries are fundamentally implemented with a HashTable they do have some key difference one of which will be highlighted here. It can be the case that the hash will end up being at the same spot in the table, if that's the case then for a hashtable it will (**TODO: Confirm this is correct**) create a list that will be stored at that location and several objects can be placed there with the ordering being determined by order of insertion.  That is why the worst case complexity can be O(N) for hash tables.  However, **dictionaries can only store one and only one entry in the slot table.**  Thus, it can be the case that the same hash is mapped to the same slot in the table in which first it would check if that slot is empty.  If it is, it fills that slot.  However, if it isn't then it will search for another empty slot to fill.  There are methods where in which the unused parts of the hash value will be used to search for other slots (**TODO: research this**). Also, there are many other ways to do this (**TODO: add different ways**) but common ones are linear search (it will look at the slots linearly following the slot the hash retrieved) or a **randomized search/random probing** (which Python uses!) that will search slots randomly until an empty one is found.  If all slots are full, then the hash function would return a fail.  This however is not usually the case due to how it would impact speed so often the dict/hashtable would be resized beforehand (**TODO: confirm this**) when it is typically 2/3 full.  Sources for this description include: [Source1](https://stackoverflow.com/questions/9010222/how-can-python-dict-have-multiple-keys-with-same-hash) and [Source2](https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented).  **Please check out Source2 as 
Praveen Gollakota has given a far better look into how Python Dictionaries work under the hood than I ever could.**
- Again, **dictionaries can only store one and only one entry in the slot table.**
- When a new dict is initiliazed it starts with 8 slots.  [Source2](https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented)
- Dictionaries uses **open addressing** to solve hash collisions.  It will search for other spots in the dict which is essentially stored as an array.  See more in the Hash tables section or here at [wiki page.](https://en.wikipedia.org/wiki/Hash_table#Open_addressing)


## Hash Tables
- Hash tables are one of the fastest data structures for storing data that follows the *Key:Value* pairing approach.  They take up **O(N)** space complexity and their operation speeds are: **O(1)** for best-case of insert, fetch, and delete and **O(n)** for worst-case of insert, fetch, and delete.  The best case speeds occur when a good hash function is utilized and as such there is only one key:value pair filling in each bucket of the hash table.  The worst case occurs with a unoptimal hash function is utlized resulting in several data objects being placed in the same bucket.  This causes the operations' speed at that bucket to increase to O(n) due to the resulting search for the appropriate key have to look through an array or linked list rather than just a single key value.  Worst-case complexity can also occur when the hash table is full leading to the neccessary steps of rehashing each key:value pair in a larger hash table.  See [this](https://stackoverflow.com/questions/9214353/hash-table-runtime-complexity-insert-search-and-delete) for a more concrete answer to the complexity speeds and reasoning.
- Another option rather than Hash Tables is the commonly used **Red-Black Trees** data structure.  A hash table is often the preffered structure to use due to its advantage in average operation speed and easier implementation.  However, it is the case that although the RB Tree is harder to implement and has worst-average case complexity; it will self-balance (resize) and its operation speeds are O(logN) for insert, fetch and delete for both best and worst case with the same space complexity of O(N).  Thus, there are cases in which the RB Tree could perform better.  See [this](https://softwareengineering.stackexchange.com/questions/234793/why-does-python-use-hash-table-to-implement-dict-but-not-red-black-tree) for the full answer to this question.
-**Hash Collision** is when a hash value is indexed to a non-empty slot i.e more than one data object in that location of table.  There are many ways that this is handled such as: (**TODO**: Fill)


## Functions
- **enumerate()** - when dealing with iterators often need the count as well.  This is python's built-in function for that purpose.  [Source](https://www.geeksforgeeks.org/enumerate-in-python/)
-Counter() - will go through an iterable and create a dict with elem:count as key:value pair
